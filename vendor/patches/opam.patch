diff --git a/vendor/opam/src/core/custom_opamStubs.c b/vendor/opam/src/core/custom_opamStubs.c
--- a/vendor/opam/src/core/custom_opamStubs.c
+++ b/vendor/opam/src/core/custom_opamStubs.c
@@ -6,7 +6,7 @@
 #include <caml/memory.h>
 #include <caml/osdeps.h>
 #include <caml/alloc.h>
-#include <Windows.h>
+#include <windows.h>
 
 typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS2) (HANDLE, USHORT *, USHORT *);
 
@@ -80,20 +80,20 @@ CAMLprim value OPAMW_GetArchitecture(value unit)
 
 #else
 
-static void fail ()
-{
-  caml_failwith("Windows stubs are only allowed to be called on Windows.");
-}
+static char * unavailable_message =
+  "Windows stubs are only allowed to be called on Windows.";
 
 
 CAMLprim value OPAMW_GetWindowsVersion(value unit)
 {
-  fail ();
+  (void)unit;
+  caml_failwith(unavailable_message);
 }
 
 CAMLprim value OPAMW_GetArchitecture(value unit)
 {
-  fail ();
+  (void)unit;
+  caml_failwith(unavailable_message);
 }
 
 #endif
diff --git a/vendor/opam/src/core/opamCoreConfigDeveloper.ml b/vendor/opam/src/core/opamCoreConfigDeveloper.ml
new file mode 100644
--- /dev/null
+++ b/vendor/opam/src/core/opamCoreConfigDeveloper.ml
@@ -0,0 +1 @@
+let value = ""
diff --git a/vendor/opam/src/core/opamDirTrack.ml b/vendor/opam/src/core/opamDirTrack.ml
--- a/vendor/opam/src/core/opamDirTrack.ml
+++ b/vendor/opam/src/core/opamDirTrack.ml
@@ -9,7 +9,6 @@
 (**************************************************************************)
 
 open OpamStd.Op
-open OpamProcess.Job.Op
 
 let log ?level fmt = OpamConsole.log ?level "TRACK" fmt
 let slog = OpamConsole.slog
@@ -118,85 +117,6 @@ let item_digest = function
 let is_precise_digest d =
   not (OpamStd.String.starts_with ~prefix:"F:S" d)
 
-let track_t to_track ?(except=OpamFilename.Base.Set.empty) job_f =
-  let module SM = OpamStd.String.Map in
-  let rec make_index_topdir acc prefix dir =
-    let files =
-      try Sys.readdir (Filename.concat prefix dir)
-      with Sys_error _ as e ->
-        log "Error at dir %s: %a" (Filename.concat prefix dir)
-          (slog Printexc.to_string) e;
-        [||]
-    in
-    Array.fold_left
-      (fun acc f ->
-         let rel = Filename.concat dir f in
-         if OpamFilename.Base.(Set.mem (of_string rel) except) then acc else
-         let f = Filename.concat prefix rel in
-         try
-           let item = item_of_filename f in
-           let acc = SM.add rel item acc in
-           match item with
-           | _, Dir -> make_index_topdir acc prefix rel
-           | _ -> acc
-         with Unix.Unix_error _ as e ->
-           log "Error at %s: %a" f (slog Printexc.to_string) e;
-           acc)
-      acc files
-  in
-  let make_index =
-    match to_track with
-    | `Top dir ->
-      fun () -> make_index_topdir SM.empty (OpamFilename.Dir.to_string dir) ""
-    | `Paths (prefix, files) ->
-      fun () ->
-        List.fold_left (fun acc f ->
-            let prefix = OpamFilename.Dir.to_string prefix in
-            let rel = Filename.concat prefix f in
-            let item = item_of_filename_opt rel in
-            match item with
-            | None -> acc
-            | Some item -> SM.add f item acc)
-          SM.empty files
-  in
-  let scan_timer = OpamConsole.timer () in
-  let before = make_index () in
-  log ~level:2 "before install: %a elements scanned in %.3fs"
-    (slog @@ string_of_int @* SM.cardinal) before (scan_timer ());
-  job_f () @@| fun result ->
-  let scan_timer = OpamConsole.timer () in
-  let after = make_index () in
-  let diff =
-    SM.merge (fun _ before after ->
-        match before, after with
-        | None, None -> assert false
-        | Some _, None -> Some Removed
-        | None, Some item -> Some (Added (item_digest item))
-        | Some (perma, a), Some ((permb, b) as item) ->
-          if a = b then
-            if perma = permb then None
-            else Some (Perm_changed (item_digest item))
-          else
-          match a, b with
-          | File _, File _ | Link _, Link _
-          | Dir, Dir | Special _, Special _ ->
-            Some (Contents_changed (item_digest item))
-          | _ -> Some (Kind_changed (item_digest item)))
-      before after
-  in
-  log "after install: %a elements, %a added, scanned in %.3fs"
-    (slog @@ string_of_int @* SM.cardinal) after
-    (slog @@ string_of_int @* SM.cardinal @*
-             SM.filter (fun _ -> function Added _ -> true | _ -> false))
-    diff (scan_timer ());
-  result, diff
-
-let track_files ~prefix files ?except job_f =
-  track_t (`Paths (prefix, files)) ?except job_f
-
-let track dir ?except job_f =
-  track_t (`Top dir) ?except job_f
-
 let check_digest file digest =
   let precise = is_precise_digest digest in
   let it = item_of_filename ~precise file in
diff --git a/vendor/opam/src/core/opamDirTrack.mli b/vendor/opam/src/core/opamDirTrack.mli
--- a/vendor/opam/src/core/opamDirTrack.mli
+++ b/vendor/opam/src/core/opamDirTrack.mli
@@ -37,20 +37,6 @@ val string_of_digest: digest -> string
 (** Return the [change] action, with digest if [full] is set to true *)
 val string_of_change: ?full:bool -> change -> string
 
-(** Wraps a job to track the changes that happened under [dirname] during its
-    execution (changes done by the application of the job function to [()] are
-    tracked too, for consistency with jobs without commands) *)
-val track:
-  OpamFilename.Dir.t -> ?except:OpamFilename.Base.Set.t ->
-  (unit -> 'a OpamProcess.job) -> ('a * t) OpamProcess.job
-
-(** [track_files prefix paths ?except job] as [track] wraps a job to track
-    changes for a predefined list of [paths] (files and directories).
-    [paths] are relative to [prefix]. *)
-val track_files:
-  prefix:OpamFilename.Dir.t -> string list -> ?except:OpamFilename.Base.Set.t ->
-  (unit -> 'a OpamProcess.job) -> ('a * t) OpamProcess.job
-
 (** Removes the added and kind-changed items unless their contents changed and
     [force] isn't set, and prints warnings for other changes unless [verbose] is
     set to [false]. Ignores non-existing files.
diff --git a/vendor/opam/src/core/opamFilename.ml b/vendor/opam/src/core/opamFilename.ml
--- a/vendor/opam/src/core/opamFilename.ml
+++ b/vendor/opam/src/core/opamFilename.ml
@@ -56,9 +56,6 @@ let mk_tmp_dir () =
 let with_tmp_dir fn =
   OpamSystem.with_tmp_dir (fun dir -> fn (Dir.of_string dir))
 
-let with_tmp_dir_job fjob =
-  OpamSystem.with_tmp_dir_job (fun dir -> fjob (Dir.of_string dir))
-
 let rmdir dirname =
   OpamSystem.remove_dir (Dir.to_string dirname)
 
@@ -101,13 +98,6 @@ let in_dir dirname fn = OpamSystem.in_dir dirname fn
 
 let env_of_list l = Array.of_list (List.rev_map (fun (k,v) -> k^"="^v) l)
 
-let exec dirname ?env ?name ?metadata ?keep_going cmds =
-  let env = match env with
-    | None   -> None
-    | Some l -> Some (env_of_list l) in
-  in_dir dirname
-    (fun () -> OpamSystem.commands ?env ?name ?metadata ?keep_going cmds)
-
 let move_dir ~src ~dst =
   OpamSystem.mv (Dir.to_string src) (Dir.to_string dst)
 
@@ -357,21 +347,6 @@ let copy_in ?root = process_in ?root copy
 let is_archive filename =
   OpamSystem.is_archive (to_string filename)
 
-let extract filename dirname =
-  OpamSystem.extract (to_string filename) ~dir:(Dir.to_string dirname)
-
-let extract_job filename dirname =
-  OpamSystem.extract_job (to_string filename) ~dir:(Dir.to_string dirname)
-
-let extract_in filename dirname =
-  OpamSystem.extract_in (to_string filename) ~dir:(Dir.to_string dirname)
-
-let extract_in_job filename dirname =
-  OpamSystem.extract_in_job (to_string filename) ~dir:(Dir.to_string dirname)
-
-let make_tar_gz_job filename dirname =
-  OpamSystem.make_tar_gz_job (to_string filename) ~dir:(Dir.to_string dirname)
-
 type generic_file =
   | D of Dir.t
   | F of t
@@ -382,7 +357,6 @@ let extract_generic_file filename dirname =
     log "extracting %a to %a"
       (slog to_string) f
       (slog Dir.to_string) dirname;
-    extract f dirname
   | D d ->
     if d <> dirname then (
       log "copying %a to %a"
@@ -429,9 +403,6 @@ let link ?(relative=false) ~target ~link =
   OpamSystem.link target (to_string link)
 [@@ocaml.warning "-16"]
 
-let patch ?preprocess filename dirname =
-  OpamSystem.patch ?preprocess ~dir:(Dir.to_string dirname) (to_string filename)
-
 let flock flag ?dontblock file = OpamSystem.flock flag ?dontblock (to_string file)
 
 let with_flock flag ?dontblock file f =
diff --git a/vendor/opam/src/core/opamFilename.mli b/vendor/opam/src/core/opamFilename.mli
--- a/vendor/opam/src/core/opamFilename.mli
+++ b/vendor/opam/src/core/opamFilename.mli
@@ -58,10 +58,6 @@ val in_dir: Dir.t -> (unit -> 'a) -> 'a
 (** Turns an assoc list into an array suitable to be provided as environment *)
 val env_of_list: (string * string) list -> string array
 
-(** Execute a list of commands in a given directory *)
-val exec: Dir.t -> ?env:(string * string) list -> ?name:string ->
-  ?metadata:(string * string) list -> ?keep_going:bool -> string list list -> unit
-
 (** Move a directory *)
 val move_dir: src:Dir.t -> dst:Dir.t -> unit
 
@@ -93,9 +89,6 @@ val raw_dir: string -> Dir.t
 (** Execute a function in a temp directory *)
 val with_tmp_dir: (Dir.t -> 'a) -> 'a
 
-(** Provide an automatically cleaned up temp directory to a job *)
-val with_tmp_dir_job: (Dir.t -> 'a OpamProcess.job) -> 'a OpamProcess.job
-
 (** Raw function to create a temporary directory. No automatic cleanup *)
 val mk_tmp_dir: unit -> Dir.t
 
@@ -221,20 +214,6 @@ val link: ?relative:bool -> target:t -> link:t -> unit
 (** Returns true if the given file is an archive (zip or tar) *)
 val is_archive: t -> bool
 
-(** Extract an archive in a given directory (it rewrites the root to
-    match [Dir.t] dir if needed) *)
-val extract: t -> Dir.t -> unit
-
-(** Same as [extract], as an OpamProcess.job *)
-val extract_job: t -> Dir.t -> exn option OpamProcess.job
-
-(** Extract an archive in a given directory *)
-val extract_in: t -> Dir.t -> unit
-
-val extract_in_job: t -> Dir.t -> exn option OpamProcess.job
-
-val make_tar_gz_job: t -> Dir.t -> exn option OpamProcess.job
-
 (** Extract a generic file *)
 val extract_generic_file: generic_file -> Dir.t -> unit
 
@@ -258,10 +237,6 @@ val remove_prefix_dir: Dir.t -> Dir.t -> string
 (** Remove a suffix from a filename *)
 val remove_suffix: Base.t -> t -> string
 
-(** Apply a patch in a directory. If [preprocess] is set to false, there is no
-    CRLF translation. Returns [None] on success, the process error otherwise *)
-val patch: ?preprocess:bool -> t -> Dir.t -> exn option OpamProcess.job
-
 (** Create an empty file *)
 val touch: t -> unit
 
diff --git a/vendor/opam/src/core/opamSystem.ml b/vendor/opam/src/core/opamSystem.ml
--- a/vendor/opam/src/core/opamSystem.ml
+++ b/vendor/opam/src/core/opamSystem.ml
@@ -14,7 +14,6 @@ type install_warning =
   | `Cygwin | `Msys2 | `Tainted of [`Msys2 | `Cygwin] | `Cygwin_libraries ]
 type install_warning_fn = string -> install_warning -> unit
 
-exception Process_error of OpamProcess.result
 exception Internal_error of string
 exception Command_not_found of string
 exception File_not_found of string
@@ -29,13 +28,6 @@ let internal_error fmt =
     raise (Internal_error str)
   ) fmt
 
-let process_error r =
-  if r.OpamProcess.r_signal = Some Sys.sigint then raise Sys.Break
-  else raise (Process_error r)
-
-let raise_on_process_error r =
-  if OpamProcess.is_failure r then raise (Process_error r)
-
 let command_not_found cmd =
   raise (Command_not_found cmd)
 
@@ -365,11 +357,6 @@ let in_tmp_dir fn =
   with_tmp_dir @@ fun dir ->
     in_dir dir fn
 
-let with_tmp_dir_job fjob =
-  let dir = mk_temp_dir () in
-  mkdir dir;
-  OpamProcess.Job.finally (fun () -> remove_dir dir) (fun () -> fjob dir)
-
 let remove file =
   if (try Sys2.is_directory file with Sys_error _ -> false) then
     remove_dir file
@@ -427,145 +414,6 @@ let back_to_forward =
   else
     fun x -> x
 
-(* OCaml 4.05.0 no longer follows the updated PATH to resolve commands. This
-   makes unqualified commands absolute as a workaround. *)
-let t_resolve_command =
-  let is_external_cmd name =
-    let name = forward_to_back name in
-    OpamStd.String.contains_char name Filename.dir_sep.[0]
-  in
-  let check_perms =
-    if Sys.win32 then fun f ->
-      try (Unix.stat f).Unix.st_kind = Unix.S_REG
-      with e -> OpamStd.Exn.fatal e; false
-    else fun f ->
-      try
-        let open Unix in
-        let uid = geteuid () in
-        let groups = OpamStd.IntSet.of_list (getegid () :: Array.to_list (getgroups ())) in
-        let {st_uid; st_gid; st_perm; _} = stat f in
-        let mask =
-          if uid = st_uid then
-            0o100
-          else if OpamStd.IntSet.mem st_gid groups then
-            0o010
-          else
-            0o001
-        in
-        if (st_perm land mask) <> 0 then
-          true
-        else
-          match OpamACL.get_acl_executable_info f st_uid with
-          | None -> false
-          | Some [] -> true
-          | Some gids -> OpamStd.IntSet.(not (is_empty (inter (of_list gids) groups)))
-      with e -> OpamStd.Exn.fatal e; false
-  in
-  let resolve ?dir env name =
-    if not (Filename.is_relative name) then begin
-      (* absolute path *)
-      if not (Sys.file_exists name) then `Not_found
-      else if not (check_perms name) then `Denied
-      else `Cmd name
-    end else if is_external_cmd name then begin
-      (* relative path *)
-      let cmd = match dir with
-        | None -> name
-        | Some d -> Filename.concat d name
-      in
-      if not (Sys.file_exists cmd) then `Not_found
-      else if not (check_perms cmd) then `Denied
-      else `Cmd cmd
-    end else
-    (* bare command, lookup in PATH *)
-    (* Following the shell sematics for looking up PATH, programs with the
-       expected name but not the right permissions are skipped silently.
-       Therefore, only two outcomes are possible in that case, [`Cmd ..] or
-       [`Not_found]. *)
-    let path = OpamStd.Sys.split_path_variable (env_var env "PATH") in
-    let name =
-      if Sys.win32 && not (Filename.check_suffix name ".exe") then
-        name ^ ".exe"
-      else name
-    in
-    let possibles = OpamStd.List.filter_map (fun path ->
-        let candidate = Filename.concat path name in
-        if Sys.file_exists candidate then Some candidate else None) path
-    in
-    match List.find check_perms possibles with
-    | cmdname -> `Cmd cmdname
-    | exception Not_found ->
-      if possibles = [] then
-        `Not_found
-      else
-        `Denied
-  in
-  fun ?env ?dir name ->
-    let env = match env with None -> OpamProcess.default_env () | Some e -> e in
-    resolve env ?dir name
-
-let resolve_command ?env ?dir name =
-  match t_resolve_command ?env ?dir name with
-  | `Cmd cmd -> Some cmd
-  | `Denied | `Not_found -> None
-
-let apply_cygpath name =
-  (* XXX Deeper bug, looking in the cygvoke code (see OpamProcess.create) *)
-  match resolve_command "cygpath" with
-  | Some cygpath ->
-    let r =
-      OpamProcess.run
-        (OpamProcess.command ~name:(temp_file "command")
-           ~allow_stdin:false ~verbose:false cygpath ["--"; name])
-    in
-    OpamProcess.cleanup ~force:true r;
-    if OpamProcess.is_success r then
-      match r.OpamProcess.r_stdout with
-      | l::_ -> l
-      | _ -> ""
-    else
-      OpamConsole.error_and_exit `Internal_error "Could not apply cygpath to %s" name
-  | None ->
-    OpamConsole.error_and_exit `Internal_error "Could not apply cygpath to %s" name
-
-let get_cygpath_function =
-  if Sys.win32 then
-    fun ~command ->
-      lazy (
-        if OpamStd.Option.map_default
-            (OpamStd.Sys.is_cygwin_variant
-               ~cygbin:(OpamCoreConfig.(!r.cygbin)))
-               false
-               (resolve_command command) then
-          apply_cygpath
-        else fun x -> x
-      )
-  else
-    let f = Lazy.from_val (fun x -> x) in
-    fun ~command:_ -> f
-
-let apply_cygpath_path_transform path =
-  let r =
-    OpamProcess.run
-      (OpamProcess.command ~name:(temp_file "command") ~verbose:false "cygpath" ["--path"; "--"; path])
-  in
-  OpamProcess.cleanup ~force:true r;
-  if OpamProcess.is_success r then
-    List.hd r.OpamProcess.r_stdout
-  else
-    OpamConsole.error_and_exit `Internal_error "Could not apply cygpath --path to %s" path
-
-let get_cygpath_path_transform =
-  (* We are running in a functioning Cygwin or MSYS2 environment if and only
-     if `cygpath` is in the PATH. *)
-  if Sys.win32 then
-    lazy (
-      match resolve_command "cygpath" with
-      | Some _ -> apply_cygpath_path_transform
-      | None -> fun x -> x)
-  else
-    Lazy.from_val (fun x -> x)
-
 let runs = ref []
 let print_stats () =
   match !runs with
@@ -576,94 +424,6 @@ let print_stats () =
 
 let log_file ?dir name = temp_file ?dir (OpamStd.Option.default "log" name)
 
-let make_command
-    ?verbose ?env ?name ?text ?metadata ?allow_stdin ?stdout
-    ?dir ?(resolve_path=true)
-    cmd args =
-  let env = match env with None -> OpamProcess.default_env () | Some e -> e in
-  let name = log_file name in
-  let verbose =
-    OpamStd.Option.default OpamCoreConfig.(!r.verbose_level >= 2) verbose
-  in
-  let full_cmd =
-    if resolve_path then t_resolve_command ~env ?dir cmd
-    else `Cmd cmd
-  in
-  match full_cmd with
-  | `Cmd cmd ->
-    OpamProcess.command
-      ~env ~name ?text ~verbose ?metadata ?allow_stdin ?stdout ?dir
-      cmd args
-  | `Not_found -> command_not_found cmd
-  | `Denied -> permission_denied cmd
-
-let run_process
-    ?verbose ?env ~name ?metadata ?stdout ?allow_stdin command =
-  let env = match env with None -> OpamProcess.default_env () | Some e -> e in
-  let chrono = OpamConsole.timer () in
-  runs := command :: !runs;
-  match command with
-  | []          -> invalid_arg "run_process"
-  | cmd :: args ->
-    match t_resolve_command ~env cmd with
-    | `Cmd full_cmd ->
-      let verbose = match verbose with
-        | None   -> OpamCoreConfig.(!r.verbose_level) >= 2
-        | Some b -> b in
-
-      let r =
-        OpamProcess.run
-          (OpamProcess.command
-             ~env ~name ~verbose ?metadata ?allow_stdin ?stdout
-             full_cmd args)
-      in
-      let str = String.concat " " (cmd :: args) in
-      log ~level:2 "[%a] (in %.3fs) %s"
-        (OpamConsole.slog Filename.basename) name
-        (chrono ()) str;
-      r
-    | `Not_found -> command_not_found cmd
-    | `Denied -> permission_denied cmd
-
-let command ?verbose ?env ?name ?metadata ?allow_stdin cmd =
-  let name = log_file name in
-  let r = run_process ?verbose ?env ~name ?metadata ?allow_stdin cmd in
-  OpamProcess.cleanup r;
-  raise_on_process_error r
-
-let commands ?verbose ?env ?name ?metadata ?(keep_going=false) commands =
-  let name = log_file name in
-  let run = run_process ?verbose ?env ~name ?metadata in
-  let command r0 c =
-    match r0, keep_going with
-    | (`Error _ | `Exception _), false -> r0
-    | _ ->
-      let r1 = try
-          let r = run c in
-          if OpamProcess.is_success r then `Successful r else `Error r
-        with Command_not_found _ as e -> `Exception e
-      in
-      match r0 with `Start | `Successful _ -> r1 | _ -> r0
-  in
-  match List.fold_left command `Start commands with
-  | `Start -> ()
-  | `Successful r -> OpamProcess.cleanup r
-  | `Error e -> process_error e
-  | `Exception e -> raise e
-
-let read_command_output ?verbose ?env ?metadata ?allow_stdin
-    ?(ignore_stderr=false) cmd =
-  let name = log_file None in
-  let stdout = name ^ (if ignore_stderr then ".stdout" else ".out") in
-  let r =
-    run_process ?verbose ?env ~name ?metadata ?allow_stdin
-      ~stdout
-      cmd
-  in
-  OpamProcess.cleanup r;
-  raise_on_process_error r;
-  r.OpamProcess.r_stdout
-
 let verbose_for_base_commands () =
   OpamCoreConfig.(!r.verbose_level) >= 3
 
@@ -886,22 +646,6 @@ let install ?(warning=default_install_warning) ?exec src dst =
   else
     copy_file_aux ~chmod:(fun _ -> perm) ~src ~dst ()
 
-let cpu_count () =
-  try
-    let ans =
-      let open OpamStd in
-      match Sys.os () with
-      | Sys.Win32 -> [Env.get "NUMBER_OF_PROCESSORS"]
-      | Sys.FreeBSD -> read_command_output ~verbose:(verbose_for_base_commands ())
-                         ["sysctl"; "-n"; "hw.ncpu"]
-      | _ -> read_command_output ~verbose:(verbose_for_base_commands ())
-               ["getconf"; "_NPROCESSORS_ONLN"]
-    in
-    int_of_string (List.hd ans)
-  with Not_found | Process_error _ | Failure _ -> 1
-
-open OpamProcess.Job.Op
-
 module Tar = struct
 
   type extract =
@@ -963,46 +707,12 @@ module Tar = struct
   let is_archive file =
     get_type file <> None
 
-  let check_extract file =
-    OpamStd.Option.Op.(
-      get_type file >>= fun typ ->
-      let cmd = extract_command typ in
-      let res = resolve_command cmd <> None in
-      if not res then
-        Some (Printf.sprintf "Tar needs %s to extract the archive" cmd)
-      else None)
-
   let tar_cmd = lazy (
     match OpamStd.Sys.os () with
     | OpamStd.Sys.OpenBSD -> "gtar"
     | _ -> "tar"
   )
 
-  let cygpath_tar = lazy (
-    Lazy.force (get_cygpath_function ~command:(Lazy.force tar_cmd))
-  )
-
-  let extract_command =
-    fun file ->
-      OpamStd.Option.Op.(
-        get_type file >>| fun typ ->
-        let f = Lazy.force cygpath_tar in
-        let tar_cmd = Lazy.force tar_cmd in
-        let command c dir =
-          make_command tar_cmd [ Printf.sprintf "xf%c" c ; f file; "-C" ; f dir ]
-        in
-        command (extract_option typ))
-
-  let compress_command =
-    fun file dir ->
-      let f = Lazy.force cygpath_tar in
-      let tar_cmd = Lazy.force tar_cmd in
-      make_command tar_cmd [
-        "cfz"; f file;
-        "-C" ; f (Filename.dirname dir);
-        f (Filename.basename dir)
-      ]
-
 end
 
 module Zip = struct
@@ -1022,98 +732,11 @@ module Zip = struct
       with Sys_error _ | End_of_file -> false
     else
       Filename.check_suffix f "zip"
-
-  let extract_command file =
-    Some (fun dir -> make_command "unzip" [ file; "-d"; dir ])
 end
 
 let is_archive file =
   Tar.is_archive file || Zip.is_archive file
 
-let extract_command file =
-  if Zip.is_archive file then Zip.extract_command file
-  else Tar.extract_command file
-
-let make_tar_gz_job ~dir file =
-  let tmpfile = file ^ ".tmp" in
-  remove_file tmpfile;
-  Tar.compress_command tmpfile dir @@> fun r ->
-  OpamProcess.cleanup r;
-  if OpamProcess.is_success r then
-    (mv tmpfile file; Done None)
-  else
-    (remove_file tmpfile; Done (Some (Process_error r)))
-
-let extract_job ~dir file =
-  if not (Sys.file_exists file) then
-    Done (Some (File_not_found file))
-  else
-  with_tmp_dir_job @@ fun tmp_dir ->
-  match extract_command file with
-  | None   ->
-    Done (Some (Failure ("Unknown archive type: "^file)))
-  | Some cmd ->
-    cmd tmp_dir @@> fun r ->
-    if not (OpamProcess.is_success r) then
-      if Zip.is_archive file then
-        Done (Some (Process_error r))
-      else match Tar.check_extract file with
-        | None -> Done (Some (Process_error r))
-        | Some s -> Done (Some (Failure s))
-    else if try not (Sys.is_directory dir) with Sys_error _ -> false then
-      internal_error "Extracting the archive would overwrite %s." dir
-    else
-    let flist =
-      OpamStd.Op.(
-        files_all_not_dir tmp_dir |>
-        List.filter (not @* OpamStd.String.contains ~sub:"pax_global_header"))
-    in
-    match flist with
-    | [] ->
-      begin match directories_strict tmp_dir with
-        | [x] ->
-          (try
-             mkdir (Filename.dirname dir);
-             copy_dir x dir;
-             Done None
-           with e -> OpamStd.Exn.fatal e; Done (Some e))
-        | _ ->
-          internal_error "The archive %S contains multiple root directories."
-            file
-      end
-    | _   ->
-      mkdir (Filename.dirname dir);
-      try copy_dir tmp_dir dir; Done None
-      with e -> OpamStd.Exn.fatal e; Done (Some e)
-
-let extract ~dir file =
-  match OpamProcess.Job.run (extract_job ~dir file) with
-  | Some e -> raise e
-  | None -> ()
-
-let extract_in_job ~dir file =
-  OpamProcess.Job.catch (fun e -> Done (Some e)) @@ fun () ->
-  mkdir dir;
-  match extract_command file with
-  | None -> internal_error "%s is not a valid tar or zip archive." file
-  | Some cmd ->
-    cmd dir @@> fun r ->
-    if not (OpamProcess.is_success r) then
-      if Zip.is_archive file then
-        Done (Some (Process_error r))
-      else match Tar.check_extract file with
-        | None ->
-          Done (Some (Failure
-                        (Printf.sprintf "Failed to extract archive %s: %s" file
-                           (OpamProcess.result_summary r))))
-        | Some s -> Done (Some (Failure s))
-    else Done None
-
-let extract_in ~dir file =
-  match OpamProcess.Job.run (extract_in_job ~dir file) with
-  | Some e -> raise e
-  | None -> ()
-
 let link src dst =
   let fallback () =
     (* Fall back to copy if symlinks are not supported *)
@@ -1621,32 +1244,8 @@ let translate_patch ~dir orig corrected =
   end;
   close_in ch
 
-let patch ?(preprocess=true) ~dir p =
-  if not (Sys.file_exists p) then
-    (OpamConsole.error "Patch file %S not found." p;
-     raise Not_found);
-  let p' =
-    if preprocess then
-      let p' = temp_file ~auto_clean:false "processed-patch" in
-      translate_patch ~dir p p';
-      p'
-    else
-      p
-  in
-  let patch_cmd =
-    match OpamStd.Sys.os () with
-    | OpamStd.Sys.OpenBSD
-    | OpamStd.Sys.FreeBSD -> "gpatch"
-    | _ -> "patch"
-  in
-  make_command ~name:"patch" ~dir patch_cmd ["-p1"; "-i"; p'] @@> fun r ->
-    if not (OpamConsole.debug ()) then Sys.remove p';
-    if OpamProcess.is_success r then Done None
-    else Done (Some (Process_error r))
-
 let register_printer () =
   Printexc.register_printer (function
-    | Process_error r     -> Some (OpamProcess.result_summary r)
     | Internal_error m    -> Some m
     | Command_not_found c -> Some (Printf.sprintf "%S: command not found." c)
     | Permission_denied c -> Some (Printf.sprintf "%S: permission denied." c)
@@ -1664,6 +1263,3 @@ let init () =
   Sys.catch_break true;
   try Sys.set_signal Sys.sigpipe (Sys.Signal_handle (fun _ -> ()))
   with Invalid_argument _ -> ()
-
-let () =
-  OpamProcess.set_resolve_command resolve_command
diff --git a/vendor/opam/src/core/opamSystem.mli b/vendor/opam/src/core/opamSystem.mli
--- a/vendor/opam/src/core/opamSystem.mli
+++ b/vendor/opam/src/core/opamSystem.mli
@@ -11,19 +11,10 @@
 
 (** Bindings of lots of filesystem and system operations *)
 
-(** Exception raised when subprocess fails *)
-exception Process_error of OpamProcess.result
-
 exception Command_not_found of string
 
 exception Permission_denied of string
 
-(** raise [Process_error] *)
-val process_error: OpamProcess.result -> 'a
-
-(** raise [Process_error] if the process didn't return 0 *)
-val raise_on_process_error: OpamProcess.result -> unit
-
 (** Exception raised when a computation in the current process
     fails. *)
 exception Internal_error of string
@@ -38,9 +29,6 @@ val with_tmp_dir: (string -> 'a) -> 'a
 (** [in_tmp_dir fn] executes [fn] in a temporary directory. *)
 val in_tmp_dir: (unit -> 'a) -> 'a
 
-(** Runs a job with a temp dir that is cleaned up afterwards *)
-val with_tmp_dir_job: (string -> 'a OpamProcess.job) -> 'a OpamProcess.job
-
 (** Returns true if the default verbose level for base commands (cp, mv, etc.)
     is reached *)
 val verbose_for_base_commands: unit -> bool
@@ -163,90 +151,20 @@ val dir_is_empty: string -> bool
     Links pointing to directory are also returned. *)
 val directories_with_links: string -> string list
 
-(** Make a comman suitable for OpamProcess.Job. if [verbose], is set,
-    command and output will be displayed (at command end for the
-    latter, if concurrent commands are running). [name] is used for
-    naming log files. [text] is what is displayed in the status line
-    for this command. May raise Command_not_found, unless
-    [resolve_path] is set to false (in which case you can end up
-    with a process error instead) *)
-val make_command:
-  ?verbose:bool -> ?env:string array -> ?name:string -> ?text:string ->
-  ?metadata:(string * string) list -> ?allow_stdin:bool -> ?stdout:string ->
-  ?dir:string -> ?resolve_path:bool ->
-  string -> string list -> OpamProcess.command
-
 (** OLD COMMAND API, DEPRECATED *)
 
 (** a command is a list of words *)
 type command = string list
 
-(** Test whether a command exists in the environment, and returns it (resolved
-    if found in PATH) *)
-val resolve_command: ?env:string array -> ?dir:string -> string -> string option
-
-(** Returns a function which should be applied to arguments for a given command
-    by determining if the command is the Cygwin variant of the command. Returns
-    the identity function otherwise. *)
-val get_cygpath_function: command:string -> (string -> string) lazy_t
-
-(** Returns a function which should be applied to a PATH environment variable
-    if in a functioning Cygwin or MSYS2 environment, translating the Windows or a
-    Unix PATH variable into a Unix PATH variable. Returns the identity function
-    otherwise. *)
-val get_cygpath_path_transform: (string -> string) lazy_t
-
-(** [command cmd] executes the command [cmd] in the correct OPAM
-    environment. *)
-val command: ?verbose:bool -> ?env:string array -> ?name:string ->
-  ?metadata:(string * string) list -> ?allow_stdin:bool ->
-  command -> unit
-
-(** [commands cmds] executes the commands [cmds] in the correct OPAM
-    environment. It stops whenever one command fails unless [keep_going] is set
-    to [true]. In this case, the first error is re-raised at the end. *)
-val commands: ?verbose:bool -> ?env:string array -> ?name:string ->
-  ?metadata:(string * string) list -> ?keep_going:bool -> command list -> unit
-
-(** [read_command_output cmd] executes the command [cmd] in the
-    correct OPAM environment and return the lines from output if the command
-    exists normally. If the command does not exist or if the command exited
-    with a non-empty exit-code, throw an error.
-    It returns stdout and stder combiend, unless [ignore_stderr] is st to true.
-    *)
-val read_command_output: ?verbose:bool -> ?env:string array ->
-  ?metadata:(string * string) list ->  ?allow_stdin:bool ->
-  ?ignore_stderr:bool -> command -> string list
-
 (** END *)
 
 (** Test whether the file is an archive, by looking as its extension *)
 val is_archive: string -> bool
 
-(** [extract ~dir:dirname filename] extracts the archive [filename] into
-    [dirname]. [dirname] should not exists and [filename] should
-    contain only one top-level directory.*)
-val extract: dir:string -> string -> unit
-
-(** Same as [extract], but as an OpamProcess.job *)
-val extract_job: dir:string -> string -> exn option OpamProcess.job
-
-(** [extract_in ~dir:dirname filename] extracts the archive [filename] into
-    [dirname]. *)
-val extract_in: dir:string -> string -> unit
-
-(** [extract_in_job] is similar to [extract_in], but as a job *)
-val extract_in_job: dir:string -> string -> exn option OpamProcess.job
-
-val make_tar_gz_job: dir:string -> string -> exn option OpamProcess.job
-
 (** Create a directory. Do not fail if the directory already
     exist. *)
 val mkdir: string -> unit
 
-(** Get the number of active processors on the system *)
-val cpu_count: unit -> int
-
 (** {2 File locking function} *)
 
 (** Unix file locks (mutable structure, to follow actual semantics) *)
@@ -295,11 +213,6 @@ val get_lock_fd: lock -> Unix.file_descr
 
 (** {2 Misc} *)
 
-(** Apply a patch file in the current directory. If [preprocess] is set to
-    false, there is no CRLF translation. Returns the error if the patch didn't
-    apply. *)
-val patch: ?preprocess:bool -> dir:string -> string -> exn option OpamProcess.job
-
 (** Returns the end-of-line encoding style for the given file. [None] means that
     either the encoding of line endings is mixed, or the file contains no line
     endings at all (an empty file, or a file with one line and no EOL at EOF).
diff --git a/vendor/opam/src/core/opamVersionCompare.ml b/vendor/opam/src/core/opamVersionCompare.ml
--- a/vendor/opam/src/core/opamVersionCompare.ml
+++ b/vendor/opam/src/core/opamVersionCompare.ml
@@ -20,37 +20,32 @@ let is_digit = function
 (* [skip_while_from i f w m] yields the index of the leftmost character
  * in the string [s], starting from [i], and ending at [m], that does
  * not satisfy the predicate [f], or [length w] if no such index exists.  *)
-let skip_while_from i f w m =
-  let rec loop i =
-    if i = m then i
-    else if f w.[i] then loop (i + 1) else i
-  in loop i
-;;
+let rec skip_while_from i f w m =
+  if i = m then i
+  else if f w.[i] then skip_while_from (i + 1) f w m else i
 
 (* splits a version into (epoch,rest), without the separating ':'. The
  * epoch is delimited by the leftmost occurrence of ':' in x, and is ""
  * in case there is no ':' in x.  *)
 let extract_epoch x =
-  try
-    let ci = String.index x ':' in
-    let epoch = String.sub x 0 ci
-    and rest = String.sub x (ci + 1) (String.length x - ci - 1)
-    in (epoch,rest)
-  with
-    | Not_found -> ("",x)
+  match String.index_opt x ':' with
+  | None -> ("", x)
+  | Some ci ->
+      let epoch = String.sub x 0 ci
+      and rest = String.sub x (ci + 1) (String.length x - ci - 1)
+      in (epoch,rest)
 ;;
 
 (* splits a version into (prefix,revision). The revision starts on the
  * right-most occurrence of '-', or is empty in case the version does
  * not contain '-'.  *)
 let extract_revision x =
-  try
-    let di = String.rindex x '-' in
+  match String.rindex_opt x '-' with
+  | None -> (x, "")
+  | Some di ->
     let before = String.sub x 0 di in
     let after = String.sub x (di+1) (String.length x - di -1) in
     (before,after)
-  with
-    | Not_found -> (x,"")
 ;;
 
 (* character comparison uses a modified character ordering: '~' first,
diff --git a/vendor/opam/src/core/opamVersionInfo.ml b/vendor/opam/src/core/opamVersionInfo.ml
new file mode 100644
--- /dev/null
+++ b/vendor/opam/src/core/opamVersionInfo.ml
@@ -0,0 +1 @@
+let version = "2.2.0"
diff --git a/vendor/opam/src/format/opamFilter.ml b/vendor/opam/src/format/opamFilter.ml
--- a/vendor/opam/src/format/opamFilter.ml
+++ b/vendor/opam/src/format/opamFilter.ml
@@ -8,7 +8,6 @@
 (*  exception on linking described in the file LICENSE.                   *)
 (*                                                                        *)
 (**************************************************************************)
-
 open OpamTypes
 open OpamTypesBase
 open OpamStd.Op
diff --git a/vendor/opam/src/format/opamPackage.ml b/vendor/opam/src/format/opamPackage.ml
--- a/vendor/opam/src/format/opamPackage.ml
+++ b/vendor/opam/src/format/opamPackage.ml
@@ -16,11 +16,96 @@ let slog = OpamConsole.slog
 
 module Version = struct
 
-  type version = string
+  type version_style =
+    | Triple (* E.g "1.2.3" *)
+    | V_triple (* E.g "v1.2.3" *)
+
+  let version_style_equal a b = match (a, b) with
+  | Triple, Triple | V_triple, V_triple -> true
+  | _ -> false
+
+  (* Alternative reprentation for some common patterns of version number that
+     can be efficiently compared. This is micro-optimized because solving
+     dependencies requires comparing a large number of package versions. *)
+  type version_small =
+    { int : Int64.t
+    ; style : version_style
+    ; has_suffix : [`None | `Tilde | `Some ]
+    }
+
+  type version =
+    { raw : string
+    ; small : version_small option
+    }
+
+  let empty = { raw = "" ; small = None }
 
   type t = version
 
-  let to_string x = x
+  let to_string x = x.raw
+
+  (* CR rgrinberg: get rid of this once we drop 4.08 support *)
+  let rev_concat_map t ~f =
+    let rec aux f acc = function
+      | [] -> acc
+      | x :: l ->
+        let xs = f x in
+        aux f (List.rev_append xs acc) l
+    in
+    aux f [] t
+  ;;
+
+  let concat_map t ~f = List.rev (rev_concat_map t ~f)
+
+  let small_of_string s =
+    let parts =
+      String.split_on_char '+' s
+      |> concat_map ~f:(String.split_on_char '~')
+      |> concat_map ~f:(String.split_on_char '-')
+    in
+    let has_suffix =
+      match parts with
+      | [] -> `None
+      | ["~"] -> `Tilde
+      | _ :: _ -> `Some
+    in
+    match String.split_on_char '.' (List.nth parts 0) with
+    | [] -> None
+    | major :: rest ->
+         let style, major =
+           if String.length major > 0 && major.[0] = 'v'
+           then V_triple, String.sub major 1 (String.length major - 1)
+           else Triple, major
+         in
+         let major_opt = int_of_string_opt major in
+         let minor_opt, patch_opt = match rest with
+         | [] -> Some 0, Some 0
+         | minor :: rest ->
+             let minor_opt = int_of_string_opt minor in
+             let patch_opt = match rest with
+               | [] -> Some 0
+               | [ patch ] -> int_of_string_opt patch
+               | _ ->
+                   None
+             in
+             minor_opt, patch_opt
+         in
+         match major_opt, minor_opt, patch_opt with
+         | Some major, Some minor, Some patch ->
+             let max = 2 lsl 15 - 1 in
+             if major <= max && minor <= max && patch <= max
+             then
+               (* If each part of the version number can fit in a 16-bit
+                  integer pack them into a single 64-bit int so they can be
+                  efficiently compared. *)
+               let int =
+                 (Int64.shift_left (Int64.of_int major) 32)
+                 |> Int64.logor (Int64.shift_left (Int64.of_int minor) 16)
+                 |> Int64.logor (Int64.of_int patch)
+               in
+               Some { style; int; has_suffix }
+             else None
+         | _ -> None
 
   let of_string x =
     if String.length x = 0 then failwith "Package version can't be empty";
@@ -30,11 +115,37 @@ module Version = struct
           failwith
             (Printf.sprintf "Invalid character '%c' in package version %S" c x))
       x;
-    x
-
-  let default = "dev"
-
-  let compare = OpamVersionCompare.compare
+    { raw = x
+    ; small = small_of_string x
+    }
+
+  let default = of_string "dev"
+
+  let small_compare a b =
+    if version_style_equal a.style b.style then
+      let c = Int64.compare a.int b.int in
+      if c = 0 then
+        (* Only consider the suffix if the numeric part of both versions is the same. *)
+        match a.has_suffix, b.has_suffix with
+        | `Tilde, `Tilde
+        | `None, `None -> Some 0
+        | `Tilde, `None -> Some (-1)
+        | `None, `Tilde -> Some 1
+        | _ , _ ->
+            (* If both versions have suffixes then run the full comparison. *)
+            None
+      else
+        Some c
+    else
+      None
+
+  let compare a b =
+    match a.small, b.small with
+    | Some small_a, Some small_b -> (
+      match small_compare small_a small_b with
+      | Some c -> c
+      | None -> OpamVersionCompare.compare a.raw b.raw)
+    | _ -> OpamVersionCompare.compare a.raw b.raw
 
   let equal v1 v2 =
     compare v1 v2 = 0
@@ -277,8 +388,8 @@ let names_of_packages nvset =
 
 let package_of_name_aux empty split filter nv n =
   if n = "" then empty else
-  let inf = {name = String.sub n 0 (String.length n - 1); version= ""} in
-  let sup = {name = n^"\000"; version = ""} in
+  let inf = {name = String.sub n 0 (String.length n - 1); version= Version.empty} in
+  let sup = {name = n^"\000"; version = Version.empty} in
   let _, _, nv = split inf nv in
   let nv, _, _ = split sup nv in
   filter nv
diff --git a/vendor/opam/src/format/opamPackage.mli b/vendor/opam/src/format/opamPackage.mli
--- a/vendor/opam/src/format/opamPackage.mli
+++ b/vendor/opam/src/format/opamPackage.mli
@@ -17,7 +17,10 @@
 (** Versions *)
 module Version: sig
 
-  include OpamStd.ABSTRACT
+  type t
+
+  module Set : OpamStd.SET with type elt = t
+  module Map : OpamStd.MAP with type key = t
 
   (** Compare two versions using the Debian version scheme *)
   val compare: t -> t -> int
@@ -27,6 +30,9 @@ module Version: sig
 
   (** Default version used when no version is given *)
   val default : t
+
+  val to_string : t -> string
+  val of_string : string -> t
 end
 
 (** Names *)
diff --git a/vendor/opam/src/format/opamTypes.mli b/vendor/opam/src/format/opamTypes.mli
--- a/vendor/opam/src/format/opamTypes.mli
+++ b/vendor/opam/src/format/opamTypes.mli
@@ -51,7 +51,6 @@ type std_path =
 (** Download result *)
 type 'a download =
   | Up_to_date of 'a
-  | Checksum_mismatch of OpamHash.t
   | Not_available of string option * string
   (** Arguments are respectively the short and long version of an error message.
       The usage is: the first argument is displayed on normal mode (nothing
